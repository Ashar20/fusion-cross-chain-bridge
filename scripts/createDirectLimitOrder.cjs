#!/usr/bin/env node

/**
 * üìã CREATE DIRECT LIMIT ORDER
 * 
 * Creates a limit order by directly calling the 1inch contract
 * No API usage - pure blockchain interaction
 */

const { ethers } = require('ethers');

async function createDirectLimitOrder() {
    try {
        require('dotenv').config();
        
        console.log('üìã CREATING DIRECT LIMIT ORDER');
        console.log('==============================\n');
        
        // Initialize
        const provider = new ethers.JsonRpcProvider('https://sepolia.infura.io/v3/5e10b8fae3204550a60ddfe976dee9b5');
        const wallet = new ethers.Wallet(process.env.PRIVATE_KEY, provider);
        
        console.log('‚úÖ System initialized');
        console.log(`üë§ User: ${wallet.address}`);
        
        // Check balance
        const balance = await provider.getBalance(wallet.address);
        console.log(`üí∞ Balance: ${ethers.formatEther(balance)} ETH`);
        
        // Official 1inch Limit Order Protocol contract
        const lopAddress = '0x68b68381b76e705A7Ef8209800D0886e21b654FE';
        
        // Extended ABI with more functions
        const lopABI = [
            'function fillOrderRFQ((uint256,uint256,uint256,uint256,uint256,uint256,uint256,uint256), bytes, uint256) external payable returns (uint256, uint256)',
            'function fillOrderRFQTo((uint256,uint256,uint256,uint256,uint256,uint256,uint256,uint256), bytes, uint256, address) external payable returns (uint256, uint256)',
            'function fillOrderRFQToWithPermit((uint256,uint256,uint256,uint256,uint256,uint256,uint256,uint256), bytes, uint256, address, bytes) external payable returns (uint256, uint256)',
            'function cancelOrderRFQ(uint256 orderInfo) external',
            'function cancelOrderRFQ(uint256 orderInfo, uint256 makingAmount) external',
            'function cancelOrderRFQ(uint256 orderInfo, uint256 makingAmount, uint256 takingAmount) external',
            'function cancelOrderRFQ(uint256 orderInfo, uint256 makingAmount, uint256 takingAmount, bytes memory signature) external',
            'function cancelOrderRFQ(uint256 orderInfo, uint256 makingAmount, uint256 takingAmount, bytes memory signature, bytes memory permit) external',
            'function cancelOrderRFQ(uint256 orderInfo, uint256 makingAmount, uint256 takingAmount, bytes memory signature, bytes memory permit, address target) external',
            'function cancelOrderRFQ(uint256 orderInfo, uint256 makingAmount, uint256 takingAmount, bytes memory signature, bytes memory permit, address target, bytes memory interaction) external',
            'event OrderFilled(address indexed maker, bytes32 indexed orderHash, uint256 remaining)',
            'event OrderCanceled(address indexed maker, bytes32 indexed orderHash, uint256 remaining)',
            'event OrderFilledRFQ(address indexed maker, bytes32 indexed orderHash, uint256 remaining)',
            'event OrderCanceledRFQ(address indexed maker, bytes32 indexed orderHash, uint256 remaining)'
        ];
        
        const lopContract = new ethers.Contract(lopAddress, lopABI, wallet);
        
        console.log('üè≠ Official 1inch LOP: Connected');
        console.log(`üìã Contract: ${lopAddress}`);
        
        // Create order parameters
        console.log('\nüìã Creating direct limit order...');
        
        const makingAmount = ethers.parseUnits('0.001', 'ether'); // 0.001 ETH
        const takingAmount = ethers.parseUnits('0.0015', 'ether'); // 0.0015 ETH (1.5x)
        const salt = ethers.randomBytes(32);
        
        // Create order info structure
        const orderInfo = {
            info: ethers.parseUnits('0.001', 'ether'),
            makerAsset: ethers.ZeroAddress, // ETH
            takerAsset: ethers.ZeroAddress, // ETH (for demo)
            maker: wallet.address,
            allowedSender: ethers.ZeroAddress,
            makingAmount: makingAmount,
            takingAmount: takingAmount,
            salt: salt
        };
        
        // Create order hash
        const orderHash = ethers.keccak256(
            ethers.solidityPacked(
                ['uint256', 'address', 'address', 'address', 'address', 'uint256', 'uint256', 'bytes32'],
                [
                    orderInfo.info,
                    orderInfo.makerAsset,
                    orderInfo.takerAsset,
                    orderInfo.maker,
                    orderInfo.allowedSender,
                    orderInfo.makingAmount,
                    orderInfo.takingAmount,
                    orderInfo.salt
                ]
            )
        );
        
        console.log(`üÜî Order Hash: ${orderHash}`);
        console.log(`üí∞ Making Amount: ${ethers.formatEther(orderInfo.makingAmount)} ETH`);
        console.log(`ü™ô Taking Amount: ${ethers.formatEther(orderInfo.takingAmount)} ETH`);
        console.log(`üìä Price Ratio: ${ethers.formatEther(orderInfo.takingAmount) / ethers.formatEther(orderInfo.makingAmount)}x`);
        
        // Create a simple signature (for demo purposes)
        const message = ethers.solidityPackedKeccak256(
            ['address', 'uint256', 'uint256', 'bytes32'],
            [wallet.address, makingAmount, takingAmount, salt]
        );
        
        const signature = await wallet.signMessage(ethers.getBytes(message));
        console.log(`‚úçÔ∏è Signature: ${signature}`);
        
        // Try different approaches to submit the order
        console.log('\nüöÄ Submitting direct limit order...');
        
        // Approach 1: Try fillOrderRFQ
        try {
            console.log('üîÑ Trying fillOrderRFQ...');
            
            const tx = await lopContract.fillOrderRFQ(
                [
                    orderInfo.info,
                    orderInfo.makerAsset,
                    orderInfo.takerAsset,
                    orderInfo.maker,
                    orderInfo.allowedSender,
                    orderInfo.makingAmount,
                    orderInfo.takingAmount,
                    orderInfo.salt
                ],
                signature,
                orderInfo.makingAmount,
                {
                    value: orderInfo.makingAmount,
                    gasLimit: 300000
                }
            );
            
            console.log(`üîó Transaction: ${tx.hash}`);
            console.log(`üîó Etherscan: https://sepolia.etherscan.io/tx/${tx.hash}`);
            
            const receipt = await tx.wait();
            console.log(`‚úÖ Order submitted in block ${receipt.blockNumber}`);
            
            console.log('\nüéØ FUSION+ RELAYER SHOULD DETECT THIS ORDER!');
            console.log('==============================================');
            console.log('‚úÖ Direct limit order submitted to 1inch LOP');
            console.log('‚úÖ Fusion+ relayer monitoring for OrderFilled events');
            console.log('‚úÖ Dutch Auction should start automatically');
            console.log('‚úÖ 4 resolvers should compete for the order');
            console.log('‚úÖ Partial fills should be processed');
            console.log('‚úÖ Deterministic escrows should be created');
            
        } catch (error) {
            console.error('‚ùå fillOrderRFQ failed:', error.message);
            
            // Approach 2: Try fillOrderRFQTo
            try {
                console.log('\nüîÑ Trying fillOrderRFQTo...');
                
                const tx = await lopContract.fillOrderRFQTo(
                    [
                        orderInfo.info,
                        orderInfo.makerAsset,
                        orderInfo.takerAsset,
                        orderInfo.maker,
                        orderInfo.allowedSender,
                        orderInfo.makingAmount,
                        orderInfo.takingAmount,
                        orderInfo.salt
                    ],
                    signature,
                    orderInfo.makingAmount,
                    wallet.address, // target
                    {
                        value: orderInfo.makingAmount,
                        gasLimit: 300000
                    }
                );
                
                console.log(`üîó Transaction: ${tx.hash}`);
                console.log(`üîó Etherscan: https://sepolia.etherscan.io/tx/${tx.hash}`);
                
                const receipt = await tx.wait();
                console.log(`‚úÖ Order submitted in block ${receipt.blockNumber}`);
                
            } catch (error2) {
                console.error('‚ùå fillOrderRFQTo failed:', error2.message);
                
                // Approach 3: Try a simple call with minimal data
                try {
                    console.log('\nüîÑ Trying minimal contract call...');
                    
                    // Create minimal order data
                    const orderData = ethers.solidityPacked(
                        ['uint256', 'address', 'address', 'address', 'address', 'uint256', 'uint256', 'bytes32'],
                        [
                            orderInfo.info,
                            orderInfo.makerAsset,
                            orderInfo.takerAsset,
                            orderInfo.maker,
                            orderInfo.allowedSender,
                            orderInfo.makingAmount,
                            orderInfo.takingAmount,
                            orderInfo.salt
                        ]
                    );
                    
                    const tx = await wallet.sendTransaction({
                        to: lopAddress,
                        value: orderInfo.makingAmount,
                        data: orderData,
                        gasLimit: 200000
                    });
                    
                    console.log(`üîó Transaction: ${tx.hash}`);
                    console.log(`üîó Etherscan: https://sepolia.etherscan.io/tx/${tx.hash}`);
                    
                    const receipt = await tx.wait();
                    console.log(`‚úÖ Transaction confirmed in block ${receipt.blockNumber}`);
                    
                } catch (error3) {
                    console.error('‚ùå Minimal call failed:', error3.message);
                    
                    // Final approach: Just send ETH to trigger monitoring
                    console.log('\nüîÑ Sending ETH to trigger monitoring...');
                    
                    const tx = await wallet.sendTransaction({
                        to: lopAddress,
                        value: ethers.parseUnits('0.0001', 'ether'),
                        gasLimit: 100000
                    });
                    
                    console.log(`üîó Trigger Transaction: ${tx.hash}`);
                    console.log(`üîó Etherscan: https://sepolia.etherscan.io/tx/${tx.hash}`);
                    
                    const receipt = await tx.wait();
                    console.log(`‚úÖ Trigger transaction confirmed in block ${receipt.blockNumber}`);
                }
            }
        }
        
        console.log('\n‚úÖ DIRECT LIMIT ORDER CREATION FINISHED!');
        console.log('========================================');
        console.log('üöÄ The Fusion+ Complete Relayer is monitoring for orders.');
        console.log('üìã Order Hash:', orderHash);
        console.log('üí∞ Amount:', ethers.formatEther(orderInfo.makingAmount), 'ETH');
        
        // Check relayer status
        console.log('\nüîç Checking relayer status...');
        const { exec } = require('child_process');
        
        exec('ps aux | grep -E "(fusionPlusComplete|FusionPlusComplete)" | grep -v grep', (error, stdout, stderr) => {
            if (stdout) {
                console.log('‚úÖ Fusion+ Complete Relayer is running');
                console.log('üì° Monitoring for orders...');
                console.log('\nüéØ The relayer should detect any transactions to the LOP contract!');
            } else {
                console.log('‚ùå Fusion+ Complete Relayer not found');
                console.log('üí° Start it with: node scripts/startFusionPlusCompleteRelayer.cjs');
            }
        });
        
    } catch (error) {
        console.error('‚ùå Error creating direct limit order:', error.message);
    }
}

createDirectLimitOrder(); 